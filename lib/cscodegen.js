// Generated by CoffeeScript 1.3.3
(function() {

  (function(exports) {
    var TAB, formatInterpolation, formatStringData, generate, indent, levels, needsParensWhenOnLeft, operators, parens, precedence;
    TAB = '  ';
    indent = function(code) {
      var line;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = code.split('\n');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push("" + TAB + line);
        }
        return _results;
      })()).join('\n');
    };
    parens = function(code) {
      return "(" + code + ")";
    };
    formatStringData = function(data) {
      return data.replace(/[^\x20-\x7e]|['\\]/, function(c) {
        var escape, pad;
        switch (c) {
          case '\0':
            return '\\0';
          case '\b':
            return '\\b';
          case '\t':
            return '\\t';
          case '\n':
            return '\\n';
          case '\f':
            return '\\f';
          case '\r':
            return '\\r';
          case '\'':
            return '\\\'';
          case '\\':
            return '\\\\';
          default:
            escape = (c.charCodeAt(0)).toString(16);
            pad = "0000".slice(escape.length);
            return "\\u" + pad + escape;
        }
      });
    };
    formatInterpolation = function(ast, options) {
      var left, right;
      switch (ast.className) {
        case "ConcatOp":
          left = formatInterpolation(ast.left, options);
          right = formatInterpolation(ast.right, options);
          return "" + left + right;
        case "String":
          return formatStringData(ast.data);
        default:
          return "\#{" + (generate(ast, options)) + "}";
      }
    };
    needsParensWhenOnLeft = function(ast) {
      switch (ast.className) {
        case 'Function':
        case 'BoundFunction':
        case 'FunctionApplication':
          return true;
        case 'PreIncrementOp':
        case 'PreDecrementOp':
        case 'UnaryPlusOp':
        case 'UnaryNegateOp':
        case 'LogicalNotOp':
        case 'BitNotOp':
        case 'DoOp':
        case 'TypeofOp':
        case 'DeleteOp':
          return needsParensWhenOnLeft(ast.expr);
        case 'NewOp':
          return ast["arguments"].length > 0;
        default:
          return false;
      }
    };
    levels = [['SeqOp'], ['Conditional', 'ForIn', 'ForOf', 'While'], ['FunctionApplication', 'SoakedFunctionApplication'], ['AssignOp', 'CompoundAssignOp', 'ExistsAssignOp'], ['LogicalOrOp'], ['LogicalAndOp'], ['BitOrOp'], ['BitXorOp'], ['BitAndOp'], ['ExistsOp'], ['EQOp', 'NEQOp'], ['LTOp', 'LTEOp', 'GTOp', 'GTEOp', 'InOp', 'OfOp', 'InstanceofOp'], ['LeftShiftOp', 'SignedRightShiftOp', 'UnsignedRightShiftOp'], ['AddOp', 'SubtractOp'], ['MultiplyOp', 'DivideOp', 'RemOp'], ['UnaryPlusOp', 'UnaryNegateOp', 'LogicalNotOp', 'BitNotOp', 'DoOp', 'TypeofOp', 'PreIncrementOp', 'PreDecrementOp', 'DeleteOp'], ['UnaryExistsOp', 'ShallowCopyArray', 'PostIncrementOp', 'PostDecrementOp', 'Spread'], ['NewOp'], ['MemberAccessOp', 'SoakedMemberAccessOp', 'DynamicMemberAccessOp', 'SoakedDynamicMemberAccessOp', 'ProtoMemberAccessOp', 'DynamicProtoMemberAccessOp', 'SoakedProtoMemberAccessOp', 'SoakedDynamicProtoMemberAccessOp']];
    precedence = {};
    (function() {
      var level, op, ops, _i, _len, _results;
      _results = [];
      for (level = _i = 0, _len = levels.length; _i < _len; level = ++_i) {
        ops = levels[level];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
            op = ops[_j];
            _results1.push(precedence[op] = level);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    operators = {
      SeqOp: ';',
      LogicalOrOp: '||',
      LogicalAndOp: '&&',
      BitOrOp: '|',
      BitXorOp: '^',
      BitAndOp: '&',
      EQOp: 'is',
      NEQOp: 'isnt',
      LTOp: '<',
      LTEOp: '<=',
      GTOp: '>',
      GTEOp: '>=',
      InOp: 'in',
      OfOp: 'of',
      InstanceofOp: 'instanceof',
      LeftShiftOp: '<<',
      SignedRightShiftOp: '>>',
      UnsignedRightShiftOp: '>>>',
      AddOp: '+',
      SubtractOp: '-',
      MultiplyOp: '*',
      DivideOp: '/',
      RemOp: '%',
      UnaryPlusOp: '+',
      UnaryNegateOp: '-',
      LogicalNotOp: '!',
      BitNotOp: '~',
      DoOp: 'do ',
      NewOp: 'new ',
      TypeofOp: 'typeof ',
      PreIncrementOp: '++',
      PreDecrementOp: '--',
      UnaryExistsOp: '?',
      ShallowCopyArray: '[..]',
      PostIncrementOp: '++',
      PostDecrementOp: '--',
      Spread: '...',
      FunctionApplication: '',
      SoakedFunctionApplication: '?',
      MemberAccessOp: '.',
      SoakedMemberAccessOp: '?.',
      ProtoMemberAccessOp: '::',
      SoakedProtoMemberAccessOp: '?::',
      DynamicMemberAccessOp: '',
      SoakedDynamicMemberAccessOp: '?',
      DynamicProtoMemberAccessOp: '::',
      SoakedDynamicProtoMemberAccessOp: '?::'
    };
    return exports.generate = generate = function(ast, options) {
      var a, arg, argList, args, assignee, block, body, ctor, expr, fn, i, indexingExpr, left, memberName, needsParens, op, p, paramList, parameters, prec, right, s, src, _ref;
      if (options == null) {
        options = {};
      }
      needsParens = false;
      if ((_ref = options.precedence) == null) {
        options.precedence = 0;
      }
      src = (function() {
        switch (ast.className) {
          case 'Program':
            return generate(ast.block, options);
          case 'Block':
            return ((function() {
              var _i, _len, _ref1, _results;
              _ref1 = ast.statements;
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                s = _ref1[_i];
                _results.push(generate(s, options));
              }
              return _results;
            })()).join('\n\n');
          case 'Identifier':
            return ast.data;
          case 'Int':
            return ast.data;
          case 'String':
            return "'" + (formatStringData(ast.data)) + "'";
          case 'Function':
          case 'BoundFunction':
            options.precedence = precedence['AssignmentExpression'];
            parameters = (function() {
              var _i, _len, _ref1, _results;
              _ref1 = ast.parameters;
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                p = _ref1[_i];
                _results.push(generate(p, options));
              }
              return _results;
            })();
            options.precedence = 0;
            block = generate(ast.block, options);
            paramList = ast.parameters.length > 0 ? "(" + (parameters.join(', ')) + ") " : '';
            body = (function() {
              switch (ast.block.statements.length) {
                case 0:
                  return "";
                case 1:
                  return " " + block;
                default:
                  return "\n" + (indent(block));
              }
            })();
            switch (ast.className) {
              case 'Function':
                return "" + paramList + "->" + body;
              case 'BoundFunction':
                return "" + paramList + "=>" + body;
            }
            break;
          case 'AssignOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            assignee = generate(ast.assignee, options);
            expr = generate(ast.expr, options);
            return "" + assignee + " = " + expr;
          case 'SeqOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            left = generate(ast.left, options);
            right = generate(ast.right, options);
            return "" + left + "; " + right;
          case 'LeftShiftOp':
          case 'SignedRightShiftOp':
          case 'UnsignedRightShiftOp':
          case 'AddOp':
          case 'SubtractOp':
          case 'MultiplyOp':
          case 'DivideOp':
          case 'RemOp':
          case 'ExistsOp':
            op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            left = generate(ast.left, options);
            if (needsParensWhenOnLeft(ast.left)) {
              left = "(" + left + ")";
            }
            right = generate(ast.right, options);
            return "" + left + " " + op + " " + right;
          case 'UnaryPlusOp':
          case 'UnaryNegateOp':
          case 'LogicalNotOp':
          case 'BitNotOp':
          case 'DoOp':
          case 'TypeofOp':
          case 'PreIncrementOp':
          case 'PreDecrementOp':
            op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            return "" + op + (generate(ast.expr, options));
          case 'UnaryExistsOp':
          case 'PostIncrementOp':
          case 'PostDecrementOp':
          case 'Spread':
            op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            expr = generate(ast.expr, options);
            if (needsParensWhenOnLeft(ast.expr)) {
              expr = "(" + expr + ")";
            }
            return "" + expr + op;
          case 'PreIncrementOp':
          case 'PreDecrementOp':
          case 'UnaryPlusOp':
          case 'UnaryNegateOp':
          case 'LogicalNotOp':
          case 'BitNotOp':
          case 'DoOp':
          case 'TypeofOp':
          case 'DeleteOp':
            op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            return "" + op + (generate(ast.expr, options));
          case 'NewOp':
            op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            ctor = generate(ast.ctor, options);
            if (ast["arguments"].length > 0 && needsParensWhenOnLeft(ast.ctor)) {
              ctor = "(" + ctor + ")";
            }
            options.precedence = precedence['AssignOp'];
            args = (function() {
              var _i, _len, _ref1, _results;
              _ref1 = ast["arguments"];
              _results = [];
              for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                a = _ref1[i];
                arg = generate(a, options);
                if ((needsParensWhenOnLeft(a)) && i + 1 !== ast["arguments"].length) {
                  arg = "(" + arg + ")";
                }
                _results.push(arg);
              }
              return _results;
            })();
            args = args.join(', ');
            if (ast["arguments"].length > 0) {
              args = " " + args;
            }
            return "" + op + ctor + args;
          case 'FunctionApplication':
          case 'SoakedFunctionApplication':
            op = operators[ast.className];
            options.precedence = precedence[ast.className];
            fn = generate(ast["function"], options);
            if (needsParensWhenOnLeft(ast["function"])) {
              fn = "(" + fn + ")";
            }
            args = (function() {
              var _i, _len, _ref1, _results;
              _ref1 = ast["arguments"];
              _results = [];
              for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                a = _ref1[i];
                arg = generate(a, options);
                if ((needsParensWhenOnLeft(a)) && i + 1 !== ast["arguments"].length) {
                  arg = "(" + arg + ")";
                }
                _results.push(arg);
              }
              return _results;
            })();
            argList = ast["arguments"].length === 0 ? '()' : " " + (args.join(', '));
            return "" + fn + op + argList;
          case 'MemberAccessOp':
          case 'SoakedMemberAccessOp':
          case 'ProtoMemberAccessOp':
          case 'SoakedProtoMemberAccessOp':
            op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            expr = generate(ast.expr, options);
            memberName = generate(ast.memberName, options);
            return "" + expr + op + memberName;
          case 'DynamicMemberAccessOp':
          case 'SoakedDynamicMemberAccessOp':
          case 'DynamicProtoMemberAccessOp':
          case 'SoakedDynamicProtoMemberAccessOp':
            op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options.precedence = prec;
            expr = generate(ast.expr, options);
            options.precedence = 0;
            indexingExpr = generate(ast.indexingExpr, options);
            return "" + expr + op + "[" + indexingExpr + "]";
          case 'ConcatOp':
            left = formatInterpolation(ast.left, options);
            right = formatInterpolation(ast.right, options);
            return "\"" + left + right + "\"";
          default:
            throw new Error("Non-exhaustive patterns in case: " + ast.className);
        }
      })();
      if (needsParens) {
        return parens(src);
      } else {
        return src;
      }
    };
  })(typeof exports !== "undefined" && exports !== null ? exports : this.cscodegen = {});

}).call(this);
